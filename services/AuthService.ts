import { apiService } from './ApiService';
import AsyncStorage from '@react-native-async-storage/async-storage';
import type { ApiResponse } from '../types/api';
import type { User, LoginRequest, RegisterRequest, ConfirmAccountRequest, VerifyTokenResponse } from '../types/auth';
import { API_CONFIG } from './ApiConfig';

// Type pour la r√©ponse d'authentification locale
interface AuthResponse {
  token: string;
  user: User;
  expiresAt: string;
}

/**
 * Service d'authentification utilisant l'ApiService
 */
class AuthService {
  private currentUser: User | null = null;
  private authToken: string | null = null;
  
  // Cl√©s de stockage
  private readonly STORAGE_KEYS = {
    AUTH_TOKEN: '@iven_auth_token',
    USER_DATA: '@iven_user_data',
    AUTH_EXPIRES: '@iven_auth_expires'
  };

  /**
   * Initialisation du service - √† appeler au d√©marrage de l'app
   */
  async initialize(): Promise<boolean> {
    try {
      // Tentative de r√©paration des donn√©es corrompues
      await this.repairStoredAuth();
      
      const token = await AsyncStorage.getItem(this.STORAGE_KEYS.AUTH_TOKEN);
      
      // Si pas de token stock√©, pas d'authentification
      if (!token) {
        console.info('‚ÑπÔ∏è Aucun token d\'authentification trouv√©');
        return false;
      }

      // R√©cup√©rer les donn√©es utilisateur stock√©es localement en premier
      const storedUserData = await AsyncStorage.getItem(this.STORAGE_KEYS.USER_DATA);
      let localUser: User | null = null;
      
      if (storedUserData) {
        try {
          localUser = JSON.parse(storedUserData);
          if (localUser) {
            console.info('üì± Donn√©es utilisateur locales r√©cup√©r√©es:', localUser.email);
          }
        } catch (parseError) {
          console.warn('‚ö†Ô∏è Erreur parsing donn√©es utilisateur locales:', parseError);
        }
      }

      // V√©rifier la validit√© du token avec l'API
      console.info('üîê V√©rification du token JWT...');
      const verificationResult = await this.verifyToken(token);
      
      if (verificationResult.success && verificationResult.data?.isConnected) {
        // Token valide - restaurer la session avec les donn√©es de l'API
        this.authToken = token;
        
        // V√©rifier si l'API retourne tous les champs n√©cessaires
        const apiUser = verificationResult.data.user!;
        const hasAllRequiredFields = apiUser.fname && apiUser.lname && apiUser.active !== undefined;
        
        if (hasAllRequiredFields) {
          // L'API retourne tous les champs - utiliser directement
          this.currentUser = apiUser;
          console.info('‚úÖ API retourne tous les champs n√©cessaires');
        } else {
          // L'API ne retourne pas tous les champs - fusionner avec les donn√©es locales
          console.warn('‚ö†Ô∏è API ne retourne pas tous les champs, fusion avec donn√©es locales...');
          
          if (localUser) {
            // Fusionner : API en priorit√©, donn√©es locales en compl√©ment
            this.currentUser = {
              ...localUser,           // Donn√©es locales (incluant fname, lname, active)
              ...apiUser,             // Donn√©es API (id, username, email)
              updated_at: new Date().toISOString() // Marquer comme mis √† jour
            };
            console.info('‚úÖ Donn√©es fusionn√©es API + locales');
          } else {
            // Pas de donn√©es locales - utiliser l'API m√™me incompl√®te
            this.currentUser = apiUser;
            console.warn('‚ö†Ô∏è Utilisation des donn√©es API incompl√®tes (pas de donn√©es locales)');
          }
        }
        
        apiService.setAuthToken(token);
        
        // Log de d√©bogage pour voir les donn√©es finales
        console.log('üîç Donn√©es utilisateur finales apr√®s fusion:', {
          id: this.currentUser.id,
          email: this.currentUser.email,
          username: this.currentUser.username,
          fname: this.currentUser.fname,
          lname: this.currentUser.lname,
          active: this.currentUser.active,
          source: hasAllRequiredFields ? 'API compl√®te' : 'Fusion API+locales'
        });
        
        // IMPORTANT: Synchroniser le stockage local avec les donn√©es finales
        try {
          const updatedAuthData = {
            token,
            user: this.currentUser,
            expiresAt: new Date(Date.now() + 72 * 60 * 60 * 1000).toISOString()
          };
          await this.persistAuthData(updatedAuthData);
          console.info('üíæ Stockage local synchronis√© avec les donn√©es finales');
        } catch (syncError) {
          console.warn('‚ö†Ô∏è Erreur synchronisation stockage local:', syncError);
          // Continuer m√™me si la synchronisation √©choue
        }
        
        console.info('‚úÖ Token JWT valide, session restaur√©e');
        return true;
      } else {
        // Token invalide ou expir√© - nettoyer
        console.warn('‚ö†Ô∏è Token JWT invalide ou expir√©, nettoyage effectu√©');
        await this.clearStoredAuth();
        return false;
      }
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'initialisation de l\'auth:', error);
      
      // En cas d'erreur r√©seau, essayer de restaurer avec les donn√©es locales
      try {
        const storedUserData = await AsyncStorage.getItem(this.STORAGE_KEYS.USER_DATA);
        const token = await AsyncStorage.getItem(this.STORAGE_KEYS.AUTH_TOKEN);
        
        if (storedUserData && token) {
          const localUser = JSON.parse(storedUserData);
          this.currentUser = localUser;
          this.authToken = token;
          apiService.setAuthToken(token);
          
          console.info('üì± Session restaur√©e depuis le stockage local (erreur r√©seau)');
          return true;
        }
      } catch (fallbackError) {
        console.warn('‚ö†Ô∏è √âchec de la restauration depuis le stockage local:', fallbackError);
      }
      
      await this.clearStoredAuth();
      return false;
    }
  }

  /**
   * V√©rifier la validit√© d'un token JWT avec l'API
   */
  async verifyToken(token: string): Promise<ApiResponse<VerifyTokenResponse>> {
    try {
      console.info('üîç V√©rification du token JWT...');
      
      // Configurer temporairement le token pour cette requ√™te
      apiService.setAuthToken(token);
      
      const response = await apiService.get<VerifyTokenResponse>(API_CONFIG.endpoints.auth.verify_token);
      
      if (response.success && response.data) {
        console.info('‚úÖ Token JWT v√©rifi√©:', response.data.message);
        return response;
      } else {
        console.warn('‚ö†Ô∏è Token JWT invalide:', response.error);
        return response;
      }
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la v√©rification du token:', error);
      
      // Analyser le type d'erreur
      let errorMessage = 'Erreur lors de la v√©rification du token';
      
      if (error.response?.status === 401) {
        errorMessage = 'Token expir√© ou invalide';
      } else if (error.response?.status === 400) {
        errorMessage = 'Aucun token fourni';
      } else if (error.code === 'NETWORK_ERROR') {
        errorMessage = 'Probl√®me de connexion internet';
      }
      
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  /**
   * Valider les donn√©es d'authentification avant sauvegarde
   */
  private validateAuthData(authData: AuthResponse): boolean {
    // V√©rification du token
    if (!authData.token || typeof authData.token !== 'string' || authData.token.trim() === '') {
      console.warn('‚ö†Ô∏è Token invalide ou manquant');
      return false;
    }

    // V√©rification des donn√©es utilisateur
    if (!authData.user || typeof authData.user !== 'object') {
      console.warn('‚ö†Ô∏è Donn√©es utilisateur manquantes ou invalides');
      return false;
    }

    // Log de d√©bogage pour voir les donn√©es re√ßues
    console.log('üîç Validation des donn√©es utilisateur:', {
      id: authData.user.id,
      email: authData.user.email,
      username: authData.user.username,
      fname: authData.user.fname,
      lname: authData.user.lname,
      fnameType: typeof authData.user.fname,
      lnameType: typeof authData.user.lname
    });

    // V√©rification des champs obligatoires de l'utilisateur
    const requiredFields = ['id', 'email', 'username', 'fname', 'lname'];
    for (const field of requiredFields) {
      const value = authData.user[field as keyof User];
      // Accepter les cha√Ænes vides comme valeurs valides
      if (value === undefined || value === null) {
        console.warn(`‚ö†Ô∏è Champ utilisateur manquant: ${field}`);
        return false;
      }
      // V√©rifier que la valeur n'est pas undefined ou null, mais accepter les cha√Ænes vides
      if (typeof value === 'string' && value.trim() === '') {
        console.info(`‚ÑπÔ∏è Champ ${field} est une cha√Æne vide (valide)`);
      } else if (typeof value === 'number' && value === 0) {
        console.info(`‚ÑπÔ∏è Champ ${field} est 0 (valide)`);
      } else if (value) {
        console.info(`‚úÖ Champ ${field} valide: ${value}`);
      }
    }

    // V√©rification de la date d'expiration (optionnelle)
    if (authData.expiresAt && typeof authData.expiresAt !== 'string') {
      console.warn('‚ö†Ô∏è Format de date d\'expiration invalide');
      return false;
    }

    if (authData.expiresAt) {
      const expiry = new Date(authData.expiresAt);
      if (isNaN(expiry.getTime())) {
        console.warn('‚ö†Ô∏è Format de date d\'expiration invalide');
        return false;
      }
    }

    console.log('‚úÖ Validation des donn√©es d\'authentification r√©ussie');
    return true;
  }

  /**
   * Persister les donn√©es d'authentification
   */
  private async persistAuthData(authData: AuthResponse): Promise<void> {
    try {
      // Validation des donn√©es avant sauvegarde
      if (!this.validateAuthData(authData)) {
        console.error('‚ùå Donn√©es d\'authentification invalides, sauvegarde annul√©e');
        return;
      }

      // Nettoyage et pr√©paration des donn√©es
      const token = authData.token.trim();
      const userData = JSON.stringify(authData.user);
      const expiresAt = authData.expiresAt || '';

      // V√©rifier que expiresAt n'est pas undefined avant de sauvegarder
      if (expiresAt === undefined) {
        console.warn('‚ö†Ô∏è expiresAt est undefined, utilisation d\'une cha√Æne vide');
      }

      await AsyncStorage.multiSet([
        [this.STORAGE_KEYS.AUTH_TOKEN, token],
        [this.STORAGE_KEYS.USER_DATA, userData],
        [this.STORAGE_KEYS.AUTH_EXPIRES, expiresAt]
      ]);
      console.info('üíæ Donn√©es d\'authentification sauvegard√©es');
    } catch (error) {
      console.error('‚ùå Erreur sauvegarde auth:', error);
      // En cas d'erreur, nettoyer le stockage pour √©viter la corruption
      await this.clearStoredAuth();
    }
  }

  /**
   * Nettoyer et r√©parer les donn√©es AsyncStorage corrompues
   */
  async repairStoredAuth(): Promise<void> {
    try {
      console.info('üîß Tentative de r√©paration des donn√©es AsyncStorage...');
      
      // R√©cup√©rer toutes les cl√©s d'authentification
      const keys = await AsyncStorage.getAllKeys();
      const authKeys = keys.filter(key => key.startsWith('@iven_'));
      
      if (authKeys.length === 0) {
        console.info('‚ÑπÔ∏è Aucune donn√©e d\'authentification trouv√©e');
        return;
      }

      // V√©rifier chaque cl√© et nettoyer si n√©cessaire
      for (const key of authKeys) {
        const value = await AsyncStorage.getItem(key);
        
        if (value === null || value === undefined || value === '') {
          console.warn(`‚ö†Ô∏è Cl√© corrompue d√©tect√©e: ${key}, suppression...`);
          await AsyncStorage.removeItem(key);
        }
      }

      console.info('‚úÖ R√©paration des donn√©es AsyncStorage termin√©e');
    } catch (error) {
      console.error('‚ùå Erreur lors de la r√©paration:', error);
      // En cas d'erreur, nettoyer compl√®tement
      await this.clearStoredAuth();
    }
  }

  /**
   * Nettoyer les donn√©es d'authentification stock√©es
   */
  private async clearStoredAuth(): Promise<void> {
    try {
      await AsyncStorage.multiRemove([
        this.STORAGE_KEYS.AUTH_TOKEN,
        this.STORAGE_KEYS.USER_DATA,
        this.STORAGE_KEYS.AUTH_EXPIRES
      ]);
      console.info('üóëÔ∏è Donn√©es d\'authentification supprim√©es');
    } catch (error) {
      console.error('‚ùå Erreur suppression auth:', error);
    }
  }

  /**
   * Exposer les setters pour le contexte d'authentification
   */
  setCurrentUser(user: User | null): void {
    this.currentUser = user;
  }

  setAuthToken(token: string | null): void {
    this.authToken = token;
    if (token) {
      apiService.setAuthToken(token);
    } else {
      apiService.removeAuthToken();
    }
  }

  /**
   * Exposer la persistance pour le contexte
   */
  async persistSession(authData: AuthResponse): Promise<void> {
    await this.persistAuthData(authData);
  }

  /**
   * Inscription d'un nouvel utilisateur
   */
  async register(userData: RegisterRequest): Promise<ApiResponse<AuthResponse>> {
    try {
      console.info('üîê Tentative d\'inscription...', userData.email);

      const response = await apiService.post<AuthResponse>('/auth/register', {
        username: userData.username,
        fname: userData.fname,
        lname: userData.lname,
        email: userData.email,
        password: userData.password,
      });

      if (response.success && response.data) {
        console.info('‚úÖ Inscription r√©ussie, email de confirmation envoy√©');
        return {
          success: true,
          data: response.data,
          message: 'Inscription r√©ussie. Veuillez v√©rifier votre email pour confirmer votre compte.'
        };
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors de l\'inscription:', error);
      return {
        success: false,
        error: error.message || 'Erreur lors de l\'inscription'
      };
    }
  }

  /**
   * Confirmation du compte utilisateur
   */
  async confirmAccount(confirmationData: ConfirmAccountRequest): Promise<ApiResponse<AuthResponse>> {
    try {
      console.info('üîê Confirmation du compte...', confirmationData.email);

      const response = await apiService.post<AuthResponse>('/auth/confirm', {
        email: confirmationData.email,
        code: confirmationData.code,
      });

      if (response.success && response.data) {
        // Le backend retourne : { message, email, token, user }
        // Transformer en format AuthResponse
        const authData: AuthResponse = {
          token: response.data.token,
          user: {
            id: response.data.user.id,
            username: response.data.user.username,
            email: response.data.user.email,
            fname: response.data.user.fname || '',
            lname: response.data.user.lname || '',
            active: 1, // Maintenant confirm√© (1 = actif)
            avatar_url: response.data.user.avatar_url,
            created_at: response.data.user.created_at || new Date().toISOString(),
            updated_at: response.data.user.updated_at || new Date().toISOString(),
          },
          expiresAt: new Date(Date.now() + 72 * 60 * 60 * 1000).toISOString(), // 72h comme backend
        };

        // Auto-login : sauvegarder les donn√©es d'authentification
        this.currentUser = authData.user;
        this.authToken = authData.token;
        apiService.setAuthToken(authData.token);

        // Persister dans le stockage local
        await this.persistAuthData(authData);
        
        console.info('‚úÖ Compte confirm√© avec succ√®s + auto-login effectu√©');
        return {
          success: true,
          data: authData,
          message: 'Compte confirm√© avec succ√®s ! Connexion automatique effectu√©e.'
        };
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la confirmation:', error);
      return {
        success: false,
        error: error.message || 'Erreur lors de la confirmation du compte'
      };
    }
  }

  /**
   * Connexion d'un utilisateur
   */
  async login(credentials: LoginRequest): Promise<ApiResponse<AuthResponse>> {
    try {
      console.info('üîê Tentative de connexion...', credentials.email);

      const response = await apiService.post<AuthResponse>('/auth/login', credentials);

      if (response.success && response.data) {
        // V√©rifier le statut du compte
        const isConfirmed = response.data.user.active === 1;
        
        if (isConfirmed) {
          // Compte confirm√© - sauvegarder compl√®tement les donn√©es d'auth
          this.currentUser = response.data.user;
          this.authToken = response.data.token;
          apiService.setAuthToken(response.data.token);
          
          // Persister la session
          await this.persistAuthData(response.data);
          
          console.info('‚úÖ Connexion r√©ussie, compte confirm√©');
          return {
            success: true,
            data: response.data,
            message: 'Connexion r√©ussie !'
          };
        } else {
          // Compte non confirm√© - ne pas sauvegarder compl√®tement
          // mais retourner les donn√©es pour que l'UI puisse les utiliser
          console.warn('‚ö†Ô∏è Connexion r√©ussie mais compte non confirm√©');
          return {
            success: true,
            data: response.data,
            message: 'Identifiants corrects mais compte non confirm√©'
          };
        }
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la connexion:', error);
      
      // Analyser le type d'erreur pour un message plus pr√©cis
      let errorMessage = error.message || 'Erreur lors de la connexion';
      
      if (error.response?.status === 401) {
        errorMessage = 'Email ou mot de passe incorrect';
      } else if (error.response?.status === 423) {
        errorMessage = 'Compte temporairement verrouill√©';
      } else if (error.response?.status === 429) {
        errorMessage = 'Trop de tentatives. Veuillez patienter.';
      } else if (error.code === 'NETWORK_ERROR') {
        errorMessage = 'Probl√®me de connexion internet';
      }
      
      return {
        success: false,
        error: errorMessage
      };
    }
  }

  /**
   * D√©connexion de l'utilisateur
   */
  async logout(): Promise<ApiResponse<void>> {
    try {
      console.info('üîê D√©connexion...');

      // Appel API pour invalidate le token c√¥t√© serveur
      const response = await apiService.post<void>('/auth/logout');

      // Nettoyer les donn√©es locales m√™me si l'API √©choue
      this.currentUser = null;
      this.authToken = null;
      apiService.removeAuthToken();
      
      // Nettoyer le stockage persistant
      await this.clearStoredAuth();
      
      console.info('‚úÖ D√©connexion r√©ussie');
      return {
        success: true,
        message: 'D√©connexion r√©ussie'
      };
    } catch (error: any) {
      console.error('‚ö†Ô∏è Erreur lors de la d√©connexion (nettoyage local effectu√©):', error);
      
      // Nettoyer quand m√™me les donn√©es locales
      this.currentUser = null;
      this.authToken = null;
      apiService.removeAuthToken();
      
      // Nettoyer le stockage persistant
      await this.clearStoredAuth();
      
      return {
        success: true,
        message: 'D√©connexion effectu√©e'
      };
    }
  }

  /**
   * Rafra√Æchissement du token d'authentification
   */
  async refreshToken(): Promise<ApiResponse<AuthResponse>> {
    try {
      console.info('üîÑ Rafra√Æchissement du token...');

      const response = await apiService.post<AuthResponse>('/auth/refresh');

      if (response.success && response.data) {
        this.authToken = response.data.token;
        apiService.setAuthToken(response.data.token);
        
        console.info('‚úÖ Token rafra√Æchi');
        return response;
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors du rafra√Æchissement:', error);
      return {
        success: false,
        error: error.message || 'Erreur lors du rafra√Æchissement du token'
      };
    }
  }

  /**
   * Demande de r√©initialisation de mot de passe
   */
  async forgotPassword(email: string): Promise<ApiResponse<void>> {
    try {
      console.info('üîê Demande de r√©initialisation...', email);

      const response = await apiService.post<void>('/auth/forgot-password', { email });

      if (response.success) {
        console.info('‚úÖ Email de r√©initialisation envoy√©');
        return {
          success: true,
          message: 'Un email de r√©initialisation a √©t√© envoy√©.'
        };
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors de la demande:', error);
      return {
        success: false,
        error: error.message || 'Erreur lors de la demande de r√©initialisation'
      };
    }
  }

  /**
   * Renvoyer le code de confirmation
   */
  async resendConfirmationCode(email: string): Promise<ApiResponse<void>> {
    try {
      console.info('üìß Renvoi du code de confirmation...', email);

      const response = await apiService.post<void>('/auth/resend-confirmation', { email });

      if (response.success) {
        console.info('‚úÖ Code de confirmation renvoy√©');
        return {
          success: true,
          message: 'Un nouveau code de confirmation a √©t√© envoy√©.'
        };
      }

      return response;
    } catch (error: any) {
      console.error('‚ùå Erreur lors du renvoi:', error);
      return {
        success: false,
        error: error.message || 'Erreur lors du renvoi du code'
      };
    }
  }

  /**
   * Synchroniser le stockage local avec les donn√©es utilisateur actuelles
   */
  async syncLocalStorage(): Promise<boolean> {
    try {
      if (!this.currentUser || !this.authToken) {
        console.warn('‚ö†Ô∏è Impossible de synchroniser: utilisateur ou token manquant');
        return false;
      }

      const authData = {
        token: this.authToken,
        user: this.currentUser,
        expiresAt: new Date(Date.now() + 72 * 60 * 60 * 1000).toISOString()
      };

      await this.persistAuthData(authData);
      console.info('üíæ Stockage local synchronis√© avec succ√®s');
      return true;
    } catch (error) {
      console.error('‚ùå Erreur synchronisation stockage local:', error);
      return false;
    }
  }

  /**
   * Restaurer la session depuis le stockage local (fallback)
   */
  async restoreFromLocalStorage(): Promise<boolean> {
    try {
      console.info('üì± Tentative de restauration depuis le stockage local...');
      
      const token = await AsyncStorage.getItem(this.STORAGE_KEYS.AUTH_TOKEN);
      const storedUserData = await AsyncStorage.getItem(this.STORAGE_KEYS.USER_DATA);
      
      if (!token || !storedUserData) {
        console.info('‚ÑπÔ∏è Aucune donn√©e locale disponible pour la restauration');
        return false;
      }
      
      const localUser = JSON.parse(storedUserData);
      
      // V√©rifier que les donn√©es utilisateur sont valides
      if (!localUser || !localUser.email || !localUser.fname || !localUser.lname) {
        console.warn('‚ö†Ô∏è Donn√©es utilisateur locales incompl√®tes');
        return false;
      }
      
      // Restaurer la session
      this.currentUser = localUser;
      this.authToken = token;
      apiService.setAuthToken(token);
      
      console.info('‚úÖ Session restaur√©e depuis le stockage local:', localUser.email);
      return true;
      
    } catch (error) {
      console.error('‚ùå Erreur lors de la restauration locale:', error);
      return false;
    }
  }

  /**
   * Obtenir l'utilisateur actuel
   */
  getCurrentUser(): User | null {
    return this.currentUser;
  }

  /**
   * Obtenir le token actuel
   */
  getAuthToken(): string | null {
    return this.authToken;
  }

  /**
   * V√©rifier si l'utilisateur est connect√©
   */
  isAuthenticated(): boolean {
    return !!(this.currentUser && this.authToken);
  }

  /**
   * V√©rifier si le compte est confirm√©
   */
  isAccountConfirmed(): boolean {
    return this.currentUser?.active === 1;
  }


}

// Instance singleton
export const authService = new AuthService();